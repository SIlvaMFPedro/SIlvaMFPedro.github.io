<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport"    content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Semi-Automatic Labelling for Atlascar using Adaptive Perception">
	<meta name="author"      content="Pedro Silva">
	
	<title>Semi-Automatic Labelling for Atlascar using Adaptive Perception > Architecture</title>

	<link rel="shortcut icon" href="assets/images/pawn_icon.png">
	
	<link rel="stylesheet" media="screen" href="//fonts.googleapis.com/css?family=Open+Sans:300,400,700">
	<link rel="stylesheet" href="assets/css/bootstrap.min.css">
	<link rel="stylesheet" href="assets/css/font-awesome.min.css">

	<!-- Custom styles for our template -->
	<link rel="stylesheet" href="assets/css/bootstrap-theme.css" media="screen" >
	<link rel="stylesheet" href="assets/css/main.css">

	<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
	<!--[if lt IE 9]>
	<script src="assets/js/html5shiv.js"></script>
	<script src="assets/js/respond.min.js"></script>
	<![endif]-->
</head>

<body>
	<!-- Fixed navbar -->
	<div class="navbar navbar-inverse navbar-fixed-top headroom" >
		<div class="container">
			<div class="navbar-header">
			</div>
			<div class="navbar-collapse collapse">
				<ul class="nav navbar-nav pull-right">
					<li><a href="index.html">Home</a></li> <!-- Client area -->
					<li class="dropdown"> <!-- Specification area -->
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Specifications<b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="specifications-1.html">Features, system scenarios and use cases</a></li>
							<li><a href="specifications-2.html">Requirements and tests</a></li>
							<li><a href="specifications-3.html">Architecture</a></li>
							<li class="active"><a href="specifications-4.html">Datasets</a></li>
							<li class="active"><a href="deliverables.html">Deliverables</a></li>
						</ul>
                    </li>
                    <li class="dropdown"> <!-- Client area -->
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">About<b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="aboutAtlas.html">About the ATLAS</a></li>
                            <li><a href="aboutCarla.html">About the CARLA</a></li>
						</ul>
                    </li>
                    <li><a href="manual.html">Integration with CARLA</a></li> <!-- Client area -->
				</ul>
			</div><!--/.nav-collapse -->
		</div>
	</div> 
	<!-- /.navbar -->

	<header id="head" class="secondary"></header>

	<!-- container -->
	<div class="container">
		
		<ol class="breadcrumb">
			<li><a href="index.html">Home</a></li>
			<li class="active">Architecture</li>
		</ol>

		<div class="row">

			<!-- Article main content -->
			<article class="col-sm-8 maincontent">
				<header class="page-header">
					<h1 class="page-title">Architecture</h1>
				</header>

				<div class="header-inside" id="spec-3-1">
					<h3>Architecture</h3>
					<hr class="half-rule"/>
					<p>&emsp;It is displayed in this section the architecture of the ROS-CARLA Integration software for the ATLASCAR implementation. Our architecture can be divided into 4 sections: one section that describes the central framework that runs with ROS, another section used for user interaction which is the CARLA simulator, another section that portrays the handling of the data between the ROS and CARLA modules and another section that is responsible for the image data processing.</p>
					<p>&emsp;The first section consists in a ROS node known as "roscore" that is responsible for handling the processes from the another ROS nodes that are part of the ATLASCAR configuration(LAR ToolKit). </p>
					<p>&emsp;The second section consists in open-world simulator known as CARLA that provides user interaction with all the agent models present in that world and command accordingly.</p>
					<p>&emsp;The third section, is the actual meat of the pie, which consists in a bridge package that handles the data provided from ROS and CARLA. To handle this complex problem of handling what we have to assume, could be an enormous amount of data, we adopt a divide and conquer strategy, aproaching the issue with a micro-services solution. Although in order to reduce the complexity of the problem we adopted a client-server model in which a user communicates with the apllication using a set of commands from the client API.</p>
					<!-- This section briefly describes the planned overall architecture of our solution. Our architecture is divided into 3 layers: <b>(1) Distributed data sources</b> (Data Generation Layer); <b>(2) IoT Platform</b> (Business Layer) and <b>(3) Applications</b> (Presentation Layer).</p>
					<p>&emsp;The distributed data sources layer sends the data gathered from the city to the IoT Platform, that stores and analyses all the data received. The IoT Platform also has the modules "AAA" and "IoT City Monitors and Alarms", that connect to the Application Layer to provide the user a fully functional and robust system. The application layer presents all the features to the user in a friendly way, with three custom applications, targeted for different users. --></p>
					<br>
					<div class="arch-div"><div class="h-caption" style="border-style: solid; border-color: grey;"><img src="./assets/images/rosgraph_carla.png" alt="The architecture of our solution"><br><h6>Architecture diagram of ROS-CARLA Integration</h6></div></div>
					<br>
					<p>&emsp;Elements of this Architecture may change according to the deemed needs faced during the development process of this software</p>
					<!-- <p>&emsp;On the <b>“Distributed data sources"</b> layer, we have a set of sensors for each type of data (lighting, waste, temperature,...). These sensors will collect data from the environment and send to an aggregator. The aggregators will send the information to a gateway, which will be the point of contact with the broker in the “IoT Platform”.</p>
					<p>&emsp;On the <b>“IoT Platform”</b>, the broker will receive the data from all the aggregators. The broker already exists in Altice Labs, and goes by the name of SmartIoT. SmartIoT is a platform that collects the data from the Altice Labs sensors that will be used in our project. The "AAA" module, where AAA stands for "Authentication, Authorization and Accounting" will be responsible for authenticate registered users. The "IoT City Monitors & Alarms" module will allow the user to add alerts to the data streams, with optional actuators defined. If any threshold is crossed, this module will notify the user and act accordingly. The module "IoT City Data Persistence" will store all the data from the IoT Platform. In some cases, it is also possible for the “IoT City Web App” to send information for the sensors (actuators). On that case, the information is sent to the SmartIoT broker, and then is sent to the sensor (actuator).</p><br>
					<p>&emsp;On the <b>“Applications”</b> layer we have the web portal, the administrator portal and the mobile application. The web portal is the interface for the city manager to see the current state of the city. The web portal uses the AAA module to authenticate its users, and receives the data from the IoT City Data Persistence. It also can add, change or delete alarms, notes and chage the state of user reports. The Administrator portal has the capability of adding sensors, streams, users, groups of users, and to do other changes on the IoT City Data Persistence Module. The IoT City Mobile Application requires no authentication, and it communicates with the IoT City Data Persistence to gather the values from sensors and create user reports.</p>  -->
					
				</div>
				
				<div class="header-inside" id="spec-3-2">
					<h3>Software Components</h3>
					<hr class="half-rule"/>
					<p>On this section we give an insight into each and every one of the components, explaining its main function and the external interface.</p>
					 
					<br><h4><b>ROS</b></h4><br>
					<p>&emsp;The central framework of this project is based on ROS Melodic on Ubuntu 18.04LTS</p>
					<p>&emsp;The ROS(Robot Operating System), although not an operating system, operates as a robotics middleware. 
									 ROS offers open-source services designed for developers that need hardware abstraction and low-level device control. 
									 Architectures in ROS are centered in applications called rosnodes which communicate with each other creating a graph of message-passing processes.
					</p>
					<p>&emsp;With ROS it is possible to receive data packets and transform them in messages that contain data from the sensors. 
									 It is possible to manipulate this data using ROS nodes and other tools.</p>


					<br><h4><b>RVIZ</b></h4><br>
					<p>&emsp;RVIZ is the standard ROS tool for 3D visualization. The Rviz is one of the most important tools as it will be used to visualize data either directly in real-time
							     by connecting a computer to the car or in rosbags. It will also serve as a debugging tool in which pointcloud values can be analyzed (ROS Wiki 2018b).</p>
					<p><img src="./assets/images/rviz_config.png"></p>

					<br><h4><b>Rosbag</b></h4><br>
					<p>&emsp;A rosbag is a file in ROS which contains messages saved from past events. While connected directly to a device, or several devices, multiple topics can be subscribed at once to be recorded into a rosbag. </p>
					<p>&emsp;The advantage of rosbags is to replicate the working environment of the ATLASCAR 2 offline. Several rosbags were recorded throughout the process of development in this project, either of calibration or for detection, tracking and labeling purposes.</p>
					<p>&emsp;In ROS, the rosbag package contains a set of tools for recording from and playing back to ROS topics. It is intended to be high performance and avoid deserialization and reserialization
									 of the messages. It also features command line tools for working with bags as well as code APIs to read/write and manipulate bags (ROS Wiki 2018a).</p>
					
					<br><h4><b>Roslaunch</b></h4><br>
					<p>&emsp; The roslaunch files are used as a tool for easily launching multiple ROS nodes. A roslaunch
							file sets up a roscore (os ROS master), sets parameters on the Parameter Server, and can also
							execute other roslaunch files.</p>
					<p>&emsp;It includes options to automatically re-spawn processes that have already died. The
							roslaunch takes in one or more XML configuration files (with the .launch extension) that
							specify the parameters to set and nodes to launch.</p>
					<p>&emsp;For example, a rosbag can be given as parameter to the roslaunch which opens the Rviz
							with a previous defined configuration to visualize the data from that rosbag.</p>
					<p>&emsp;In this project, roslaunch files are used to set up calibration values before launching the
							Rviz and the nodes that process the data from the LIDARs and the camera. The transforma-
							tions between device frames are set up using roslaunch files and static transform publishers
							implemented by ROS.</p>
					<p>&emsp;The roslaunch files are also advantageous to set up the multiple drivers needed to bring
							up the several devices equipped in the ATLASCAR 2. Since the sensors are connected to
							a network switch, the parameters given in the driver’s roslaunch file are the IP addresses of
							each of the devices. The drivers will then receive packets from the sensors and remap them
							into the ROS format.</p>

					<br><h4><b>Rqt_bag</b></h4>
					<p>&emsp;The rqt bag is a GUI to replay and display ROS bag files. In this program it is possible to
							show bag message contents, view image messages, plot message from selected topics, publish
							messages from selected topics and export messages to a new bag. The rqt bag is useful for
							the labelling process as it presents a timeline in which the user can select the time by clicking
							on it.</p>
							
					<br><h4><b>WEB User Interface - REST API</b></h4><br>
					<p>&emsp;The Chess Tourney Web Portal is the web interface between the Chess Tourney platform and any person that wants to see a game or tournament. This API uses a REST-ful engine with a set of endpoints(described below) to manage all the information, by collecting data from the GlassFish Servlets and/or Database and displaying it in the WEB API. It can show a specific game beetween two players, chess-moves, frequencies and other devolpments.</p>
					<p><img src="./assets/images/chess-web-api.png"></p>
					<p>As mentioned earlier the API uses a REST-ful engine with a set endpoints that collects data of the Game Tracker module from the Glassfish Servlets and displays it on the web Interface.</p><p>This REST-ful engine uses 7 endpoints, each with a specific purpose using the HTTP methods GET, POST and PUT:</p> 
					<br><h5><b> - POST GAME</b></h5><br>
					<p>If the user issues a POST to this endpoint by clicking in the "Click here to start new chess game" option it will create a brand new game, resetting the pieces back to their original starting positions resetting the board to its initial state</p>
					<p><img src="./assets/images/postgame.png"></p>
					<br><h5><b> - GET GAME</b></h5><br>
					<p>If the user issues a GET to this endpoint by clicking in the "Click here to look at game status" option it will return the chessboard state according to the GameTracker module</p>
					<p><img src="./assets/images/getgame.png"></p>
					<br><h5><b> - GET MOVES</b></h5><br>
					<p>If the user issues a GET to this endpoint by clicking in the "Click here to look at game moves" option it will return the current list of valid moves, given the placement of the pieces and whose turn it currently is</p>
					<p><img src="./assets/images/getmoves.png"></p>
					<br><h5><b> - POST MOVES</b></h5><br>
					<p>If the user issues a POST to this endpoint by clicking in the "Click here to check on latest moves" option it will return the chessboard state according to the last move being made on the GameTracker module or it will return the chessboard state according to a specific move specified by the user on the URL</p>
					<p><img src="./assets/images/postmoves.png"></p>
					<br><h5><b> - PUT GAME</b></h5><br>
					<p>If the user issues a PUT to this endpoint by clicking in the "Click here to check on latest game status" option it will return the chessboard state according to move id being set on the GameTracker module giving the chessboard status according to chess moves of each user</p>
					<p><img src="./assets/images/putgame1.png"> <img src="./assets/images/putgame2.png"></p>
					<br><h5><b> - GET PIECE FREQUENCY</b></h5><br>
					<p>If the user issues a GET to this endpoint by clicking in the "Click here to look at game moves" option it will return the current list of the pieces given their placement on the board as well as their play frequency according to the game status</p>
					<p><img src="./assets/images/piecesfreq.png"></p>
					<br><h5><b> - GET MOVES FREQUENCY</b></h5><br>
					<p>If the user issues a GET to this endpoint by clicking in the "Click here to check move frequency" option it will return the current list of valid moves as well as their frequency on the playlist, given the placement of the pieces and whose turn it currently is</p>
					<p><img src="./assets/images/movesfreq.png"></p>

										
					<br><h4><b>Dumper</b></h4><br>
					<p>&emsp;The Chess Tourney Dumper is a JPA persistance module that store information from Broker. It saves all the information gathered by the system, including all the Chess Moves from player's games. Within a defined interval, this component will fetch data from the current streams and save it on Database.</p>

					<br><h4><b>GlassFish Servlets</b></h4><br>
					<p>&emsp;GlassFish Servlets have the function to add the interactive web front end to the Chess Tourney, ensuring the portability and scalability of the application between broker and restAPI</p>

				</div>

				<div class="header-inside" id="spec-3-3">
					<h3>Tests</h3>
					<p><img src="./assets/images/chess-knight-and-pawn-attack.png" width="200" height="200"></p> On this section we will give an insight into the test part of each of the compenents, explaining its main functions and their purpose.
					<br><h4><b>WEB User Interface - REST API</b></h4><br>
					<p>&emsp; The API provides a series of tests using MockitoJUnitRunner class to see if the api responds accordingly.</p>
					<p> Theses tests were divided into 5 different parts</p>
					<table style="width:100%">
					  <tr>
					    <th>Test</th>
					    <th>Purpose</th> 
					  </tr>
					  <tr>
					    <td>Test Create New Game</td>
					    <td>Checks if we can create new chessboard according to the GameTracker information</td> 
					  </tr>
					  <tr>
					    <td>Test Get Fetches from Session</td>
					    <td>Checks if we can get chessboard game state from the GameTracker information</td> 
					  </tr>
					  <tr>
					  	<td>Test Put Makes with Transition</td>
					  	<td>Checks if we can get chessboard game state with the move id provided by the url</td>
					  </tr>
					  <tr>
					  	<td>Test Invalid Move Put</td>
					  	<td>Checks if the move is valid or not</td>
					  </tr>
					  <tr>
					  	<td>Test Post Game</td>
					  	<td>Checks if chessboard can be reset according to the information provided by the GameTracker</td>
					  </tr>
					</table>

			    </div>
				<div class="header-inside" id="spec-3-4">
					<h3>Deployment</h3>
					<hr class="half-rule"/>
					<p>&emsp;This section is still to be delpoyed.<img src="./assets/images/Pawn-Yellow-icon.png"></p>
				</div>
				
			</article>
			<!-- /Article -->
			
			<!-- Sidebar -->
			<aside class="col-sm-4 sidebar sidebar-right">

				<div id="sidebar" class="row widget affix">
					<div class="col-xs-12">
						<h4>Choose the topic you want to see</h4>
						<ul class="list-unstyled list-spaces">
							<li><a href="#spec-3-1">Architecture</a><br><span class="small text-muted">This section contains the schematics of the architecture of our project.</span></li>
							<li><a href="#spec-3-2">Components</a><br><span class="small text-muted">On this section we give an insight into each and<br>every one of our components.<!--, explaining its<br>main function and the interface with the exterior.--></span></li>
							<li><a href="#spec-3-3">Deployment</a><br><span class="small text-muted">Section still to be deployed<!-- On this section we explain the deployment of our system,<br>with a diagram for better understanding of the reader. --></span></li>
						</ul>
					</div>
				</div>

			</aside>
			<!-- /Sidebar -->

		</div>
	</div>	<!-- /container -->
	

	<footer id="footer" class="top-space">

		<div class="footer2">
			<div class="container">
				<div class="row">
					
					<div class="col-md-6 widget">
						<div class="widget-body">
							<p class="simplenav">Master's Thesis - Computer and Telematics Engineering</p>
						</div>
					</div>

					<div class="col-md-6 widget">
						<div class="widget-body">
							<p class="text-right">
								Copyright &copy; 2019, Master's Thesis(DETI/DEM). Designed by <a href="http://gettemplate.com/" rel="designer">gettemplate</a> 
							</p>
						</div>
					</div>

				</div> <!-- /row of widgets -->
			</div>
		</div>
	</footer>
		




	<!-- JavaScript libs are placed at the end of the document so the pages load faster -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/bootstrap.min.js"></script>
	<script src="assets/js/headroom.min.js"></script>
	<script src="assets/js/jQuery.headroom.min.js"></script>
	<script src="assets/js/template.js"></script>
</body>
</html>
